### 80. 删除有序数组中的重复项 II
```Rust
impl Solution {
    pub fn remove_duplicates(nums: &mut Vec<i32>) -> usize {
        if nums.len() <= 2 {
            return nums.len();
        }

        let mut unique_index = 2;

        for i in 2..nums.len() {
            if nums[i] != nums[unique_index - 2] {
                nums[unique_index] = nums[i];
                unique_index += 1;
            }
        }

        unique_index
    }
}
```

### 26. 删除有序数组中的重复项
```Rust
impl Solution {
    pub fn remove_duplicates(nums: &mut Vec<i32>) -> usize {
        let mut unique_set = std::collections::HashSet::new();
        nums.retain(|&x| unique_set.insert(x));
        nums.len()
    }
}
```

### 27. 移除元素
```Rust
impl Solution {
    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> usize {
        nums.retain(|&x| x != val);
        nums.len()
    }
}
```

### 88. 合并两个有序数组
```Rust
impl Solution {
    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {
        for i in 0..n {
            nums1[m as usize + i as usize] = nums2[i as usize]
        }
        nums1.sort();
    }
}
```

### 307. 区域和检索 - 数组可修改
```Rust
struct NumArray {
    nums: Vec<i32>
}


/**
 * `&self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&mut self` instead.
 */
impl NumArray {

    fn new(nums: Vec<i32>) -> Self {
        NumArray { nums }
    }
    
    fn update(&mut self, index: i32, val: i32) {
        if (index as usize) < self.nums.len() {
            // 更新数组中的元素
            self.nums[index as usize] = val;
        }
    }
    
    fn sum_range(&self, left: i32, right: i32) -> i32 {
        self.nums[(left as usize)..=(right as usize)].iter().sum()
    }
}

fn main() {
    let mut num_array = NumArray::new(vec![1, 2, 3, 4, 5]);

    println!("Original Array: {:?}", num_array.nums);

    num_array.update(2, 10);

    println!("Updated Array: {:?}", num_array.nums);

    let sum = num_array.sum_range(1, 3);
    println!("Sum of range: {}", sum);
}
```

### 2300. 咒语和药水的成功对数
```Rust
// 二分查找
impl Solution {
    pub fn successful_pairs(mut spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {
        potions.sort_unstable();
        let len = potions.len() as i32;
        let mut res: Vec<i32> = vec![];

        for s in spells.iter_mut() {
            let idx = potions.partition_point(|&x| (x as i64 * *s as i64) < success) as i32;
            if idx == len {
                *s = 0;
            } else {
                *s = len - idx;
            }
        }
        spells
    }
}

// 超时
impl Solution {
    pub fn successful_pairs(spells: Vec<i32>, potions: Vec<i32>, success: i64) -> Vec<i32> {
        let mut res: Vec<i32> = vec![];
        for s in spells {
            let mut total: i32 = 0;
            for p in &potions {
                if  (s as i64) * (*p as i64) >= success {
                    total += 1;
                }
            }
            res.push(total);
        }
        res
    }
}
```

### 2540. 最小公共值
```Rust
// 双指针 使用内存更小
impl Solution {
    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let len1= nums1.len();
        let len2 = nums2.len();
        let mut left = 0;
        let mut right = 0;

        while left < len1 &&  right < len2{
            if nums1[left] == nums2[right] {
                return nums1[left]
            }
            if nums1[left] < nums2[right] {
                left += 1
            } else {
                right += 1
            }
        }

        -1
    }
}

// 双指针
impl Solution {
    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let (mut left, mut right) = (0, 0);
        let man_len = std::cmp::max(nums1.len(), nums2.len());

        while left < man_len {
            match (nums1.get(left), nums2.get(right)) {
                (Some(v1), Some(v2)) => {
                    if v1 == v2 {
                        return *v1;
                    } else if v1 < v2 {
                        left += 1;
                    } else {
                        right += 1;
                    }
                },
                (Some(_v1), None) => break,
                (None, Some(_v2)) => break,
                (None, None) => break
            }
        }

        -1
    }
}

// 超时
impl Solution {
    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let mut res: i32 = -1;

        for n in nums1.iter() {
            if nums2.contains(n) {
                res = *n;
                break;
            }
        }
        
        res
    }
}
```

### 2609. 最长平衡子字符串
```Rust

impl Solution {
    pub fn find_the_longest_balanced_substring(s: String) -> i32 {
        let (mut x, mut y, mut z) = (0, 0, 0);
        let mut pre_char = 'a';

        for (i, c) in s.chars().enumerate() {
            if c == '1' {
                z += 1;
                x = std::cmp::max(x, std::cmp::min(y, z) * 2);
            } else if i == 0 || pre_char == '1' {
                y = 1;
                z = 0;
            } else {
                y += 1
            }
            pre_char = c;
        }

        x
    }
}
```

### 1768. 交替合并字符串
```Rust

impl Solution {
    pub fn merge_alternately(word1: String, word2: String) -> String {
        let max_len = std::cmp::max(word1.len(), word2.len());
        let mut res = String::from("");

        for i in 0..max_len {
            if i < word1.len() {
                res.push(word1.chars().nth(i).unwrap());
            }

            if i < word2.len() {
                res.push(word2.chars().nth(i).unwrap());
            }
        }

        res
    }
}
```