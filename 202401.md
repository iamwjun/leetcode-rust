## 2024-01

### 238. 除自身以外数组的乘积
```Rust
// 解法三
impl Solution {
    public fn product_except_self(nums: Vec<i32>) -> Vec<i32> {
        let mut result: Vec<i32> = Vec::new();
        let len = nums.len();

        let mut left_product = 1;
        let mut left_products = vec![1;len];
        let mut right_product = 1;
        let mut right_products = vec![1;len];
        

        for i in 1..len {
            left_product *= nums[i - 1];
            left_products[i] = left_product;

            right_product *= nums[len - i];
            right_products[len - i - 1] = right_product;
        }

        for i in 0..len {
            result.push(left_products[i] * right_products[i]);
        }

        result
    }
}

// 解法二 超时
impl Solution {
    pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {
        let mut result: Vec<i32> = Vec::new();
        let len = nums.len();

        for i in 0..len {
            let left = nums[0..i].iter().fold(1, |acc, e| acc * e);
            let right = nums[(i+1)..len].iter().fold(1, |acc, e| acc * e);

            result.push(left * right);
        }

        result
    }
}

// 解法一 有0不能通过
impl Solution {
    pub fn product_except_self(mut nums: Vec<i32>) -> Vec<i32> {
        let product = nums.iter().fold(1, |acc, e| acc * e);

        for num in &mut nums {
            *num = product / *num;
        }

        nums
    }
}
```

### 151. 反转字符串中的单词
```Rust
impl Solution {
    pub fn reverse_words(s: String) -> String {
        s.split_whitespace().rev().collect::<Vec<&str>>().join(" ")
    }
}
```