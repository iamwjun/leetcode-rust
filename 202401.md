## 2024-01

### 447. 回旋镖的数量
```Rust
// 非最终解
impl Solution {
    pub fn squared_euclidean_distance(point1: Vec<i32>, point2: Vec<i32>) -> f64 {
        ((point2[0] - point1[0]).pow(2) + (point2[1] - point1[1]).pow(2)) as f64
    }

    pub fn number_of_boomerangs(points: Vec<Vec<i32>>) -> i32 {
        let mut ret: i32 = 0;
        
        for i in 1..points.len() - 1 {
            let point1 = points[i-1].clone();
            let point2 = points[i].clone();
            let point3 = points[i].clone();
            let point4 = points[i+1].clone();

            if Solution::squared_euclidean_distance(point1, point2) == Solution::squared_euclidean_distance(point3, point4) {
                ret += 2
            }
        }

        ret
    }
}
```

### 1944. 队列中可以看到的人数
```Rust
// 解法二 单调栈
impl Solution {
    pub fn can_see_persons_count(heights: Vec<i32>) -> Vec<i32> {
        let len = heights.len();
        let mut ret: Vec<i32> = vec![0; len];
        let mut stack: Vec<i32> = Vec::new();

        for (i, &h) in heights.iter().enumerate().rev() {
            while !stack.is_empty() && *stack.last().unwrap() < h {
                stack.pop();
                ret[i] += 1;
            }
            if !stack.is_empty() {
                ret[i] += 1;
            }

            stack.push(h);
        }

        ret
    }
}

// 解法一 超时
impl Solution {
    pub fn can_see_persons_count(heights: Vec<i32>) -> Vec<i32> {
        let len = heights.len();
        let mut ret = vec![0;len];

        for i in 0..len {
            let curr = heights[i];
            let mut max_height = std::i32::MIN;
            let mut greater_curr = false;
            let mut is_greater = false;
            
            for j in i+1..len {
                let curr_j = heights[j];

                if curr_j < curr {
                    if curr_j > max_height && (!is_greater || !greater_curr) {
                        ret[i] += 1;
                    }
                } else {
                    if curr_j > max_height {
                        ret[i] += 1;
                    }
                    break;
                }

                if max_height >= curr_j && !is_greater {
                    is_greater = true;
                }

                max_height = max_height.max(curr_j);

                if max_height >= curr && !greater_curr {
                    greater_curr = true;
                }
            }
        }

        ret
    }
}
```

### 2487. 从链表中移除节点
```Rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn remove_nodes(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        match head {
            Some(mut curr) => {
                if let Some(next) = curr.next.take() {
                    let prev = Solution::remove_nodes(Some(next));
                    if curr.val < prev.as_ref().unwrap().val {
                        prev
                    } else {
                        curr.next = prev;
                        Some(curr)
                    }
                } else {
                    Some(curr)
                }
            },
            None => None,
        }
    }
}
```

### 238. 除自身以外数组的乘积
```Rust
// 解法三
impl Solution {
    public fn product_except_self(nums: Vec<i32>) -> Vec<i32> {
        let mut result: Vec<i32> = Vec::new();
        let len = nums.len();

        let mut left_product = 1;
        let mut left_products = vec![1;len];
        let mut right_product = 1;
        let mut right_products = vec![1;len];
        

        for i in 1..len {
            left_product *= nums[i - 1];
            left_products[i] = left_product;

            right_product *= nums[len - i];
            right_products[len - i - 1] = right_product;
        }

        for i in 0..len {
            result.push(left_products[i] * right_products[i]);
        }

        result
    }
}

// 解法二 超时
impl Solution {
    pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {
        let mut result: Vec<i32> = Vec::new();
        let len = nums.len();

        for i in 0..len {
            let left = nums[0..i].iter().fold(1, |acc, e| acc * e);
            let right = nums[(i+1)..len].iter().fold(1, |acc, e| acc * e);

            result.push(left * right);
        }

        result
    }
}

// 解法一 有0不能通过
impl Solution {
    pub fn product_except_self(mut nums: Vec<i32>) -> Vec<i32> {
        let product = nums.iter().fold(1, |acc, e| acc * e);

        for num in &mut nums {
            *num = product / *num;
        }

        nums
    }
}
```

### 151. 反转字符串中的单词
```Rust
impl Solution {
    pub fn reverse_words(s: String) -> String {
        s.split_whitespace().rev().collect::<Vec<&str>>().join(" ")
    }
}
```